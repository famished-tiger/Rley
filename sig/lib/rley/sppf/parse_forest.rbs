module Rley
  module SPPF
    # In an ambiguous grammar there are valid inputs that can result in multiple
    # parse trees. A set of parse trees is commonly referred to as a parse
    # forest. More specifically a parse forest is a graph data
    # structure designed to represent a set of equally syntactically correct
    # parse trees. Parse forests generated by Rley are so-called Shared Packed
    # Parse Forests (SPPF). SPPFs allow very compact representation of parse
    # trees by sharing common sub-tree amongst the parse trees.
    class ParseForest
      @root: SPPFNode

      @key2node: Hash[String, SPPFNode]

      @is_ambiguous: bool

      # The root node of the forest
      attr_reader root: SPPFNode

      # A Hash with pairs of the kind node key => node
      attr_reader key2node: Hash[String, SPPFNode]

      # A setter that tells that the parse is ambiguous.
      attr_writer is_ambiguous: bool

      # @param theRootNode [ParseForestNode] The root node of the parse tree.
      def initialize: (SPPFNode theRootNode) -> void

      # Notification that the SPPF construction is over
      def done!: () -> nil

      # Returns true if the given node is present in the forest.
      def include?: (SPPFNode aNode) -> bool

      # Returns true if the parse encountered a structural ambiguity
      # (i.e. more than one parse tree for the given input)
      def ambiguous?: () -> bool

      # Create an Enumerator that helps to iterate over the possible
      # parse trees. That enumerator will generate a parse tree when
      # called with `next` method.
      # @return [Enumerator]
      def to_ptree_enum: () -> Enumeratore

      # Part of the 'visitee' role in the Visitor design pattern.
      #   A visitee is expected to accept the visit from a visitor object
      # @param aVisitor [ParseForestVisitor] the visitor object
      def accept: (ParseForestVisitor aVisitor) -> untyped
    end
  end
end
