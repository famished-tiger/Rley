# frozen_string_literal: true

require_relative 'toml_tokenizer'
require_relative 'toml_grammar'
require_relative 'toml_ast_builder'

# A TOML parser that produce concrete parse trees.
# Concrete parse trees are the default kind of parse tree
# generated by the Rley library.
# They consist of two node types only:
# - NonTerminalNode
# - TerminalNode
# A NonTerminalNode has zero or more child nodes (called subnodes)
# A TerminalNode is leaf node, that is, it has no child node.
# While concrete parse tree nodes can be generated out of the box,
# they have the following drawbacks:
# - Generic node classes that aren't always suited for the needs of
#     the language being processing.
# - Concrete parse tree tend to be deeply nested, which may complicate
#   further processing.
class TOMLParser
  # @return [Rley::Engine] A facade object for the Rley parsing library
  attr_reader(:engine)

  def initialize
    # Create a Rley facade object
    @engine = Rley::Engine.new do |cfg|
      cfg.diagnose = true
      cfg.repr_builder = TOMLASTBuilder # Parse result will be an AST
    end

    # Step 1. Load TOML grammar
    @engine.use_grammar(TOMLGrammar)
  end

  # Parse the given TOML program into a parse tree.
  # @param source [String] TOML program to parse
  # @return [Rley::ParseTree] A parse tree equivalent to the TOML input.
  def parse(source)
    tokenizer = TOMLTokenizer.new(source)
    result = engine.parse(tokenizer.tokens)

    unless result.success?
      # Stop if the parse failed...
      line1 = "Parsing failed\n"
      line2 = "Reason: #{result.failure_reason.message}"
      raise SyntaxError, line1 + line2
    end

    engine.convert(result)
  end
end # class
