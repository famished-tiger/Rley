# frozen_string_literal: true

require 'rley'
require_relative 'loxxy_raw_scanner.rex'

class LoxxyTokenizer
  # @return [LoxxyRawScanner] Scanner generated by `oedipus_lex`gem.
  attr_reader :scanner

   # @return [String] Input text to tokenize
  attr_reader :input

  Keyword2name = begin
    lookup = %w[
      and class else false fun for if nil or
      print return super this true var while
    ].map { |x| [x, x.upcase] }.to_h
    lookup.default = 'IDENTIFIER'
    lookup.freeze
  end

  Special2name = {
    '(' => 'LEFT_PAREN',
    ')' => 'RIGHT_PAREN',
    '{' => 'LEFT_BRACE',
    '}' => 'RIGHT_BRACE',
    ',' => 'COMMA',
    '.' => 'DOT',
    '-' => 'MINUS',
    '+' => 'PLUS',
    ';' => 'SEMICOLON',
    '/' => 'SLASH',
    '*' => 'STAR',
    '!' => 'BANG',
    '!=' => 'BANG_EQUAL',
    '=' => 'EQUAL',
    '==' => 'EQUAL_EQUAL',
    '>' => 'GREATER',
    '>=' => 'GREATER_EQUAL',
    '<' => 'LESS',
    '<=' => 'LESS_EQUAL'
  }.freeze

  def initialize(source = nil)
    @scanner = LoxxyRawScanner.new
    start_with(source)
  end

  def start_with(source)
    @input = source
  end

  def tokens
    raw_tokens = scanner.parse(input)
    cooked = raw_tokens.map do |(raw_type, raw_text, line, col)|
      pos = Rley::Lexical::Position.new(line, col + 1)
      convert(raw_type, raw_text, pos)
    end
    forelast = cooked.last
    last_col = forelast.position.column + forelast.lexeme.length
    last_pos = Rley::Lexical::Position.new(forelast.position.line, last_col)
    cooked << Rley::Lexical::Token.new(nil, 'EOF', last_pos)
    cooked
  end

  private

  def convert(token_kind, token_text, pos)
    result = case token_kind
    when :SPECIAL
      Rley::Lexical::Token.new(token_text, Special2name[token_text])
    when :FALSE
      Rley::Lexical::Literal.new(false, token_text, 'FALSE')
    when :NUMBER
      num_val = token_text =~ /\.\d+$/ ? token_text.to_f : token_text.to_i
      Rley::Lexical::Literal.new(num_val, token_text, 'NUMBER')
    when :NIL
      Rley::Lexical::Literal.new(nil, token_text, 'NIL')
    when :STRING
      str_val = token_text[1..-2]
      pos.column = pos.column - 1 unless str_val.empty?
      Rley::Lexical::Literal.new(str_val, token_text, 'STRING')
    when :TRUE
      Rley::Lexical::Literal.new(true, token_text, 'TRUE')
    when :IDENTIFIER
      Rley::Lexical::Token.new(token_text, Keyword2name[token_text])
    else
      raise ScanError, "Error: [line #{pos.line}:#{column}]: Unexpected token #{token_text}"
    end

    result.position = pos
    result
  end
end # class
