# frozen_string_literal: true

require 'rley'
require_relative 'loxxy_raw_scanner.rex'

# Tokenizer for the Lox language that is compatible with a Rley parser.
# It works as an adapter between the parser and the scanner generated
# with `oedipus_lex` scanner generator.
# The purpose is to transform the output of a `LoxxyRawScanner` instance
# into o sequence of tokens in the format expected by Rley.
class LoxxyTokenizer
  # @return [LoxxyRawScanner] Scanner generated by `oedipus_lex`gem.
  attr_reader :scanner

  # @return [String] Lox input text to tokenize
  attr_reader :input

  # A Hash that maps a Lox keyword to its uppercase version
  # (a convention used in the grammar).
  # If a search is unsuccessful, it returns the string 'IDENTIFIER'
  # @return [{String => String}]
  Keyword2name = begin
    lookup = %w[
      and class else false fun for if nil or
      print return super this true var while
    ].map { |x| [x, x.upcase] }.to_h
    lookup.default = 'IDENTIFIER'
    lookup.freeze
  end

  # A Hash that maps a special character of Lox into a name
  # @return [{String => String}]
  Special2name = {
    '(' => 'LEFT_PAREN',
    ')' => 'RIGHT_PAREN',
    '{' => 'LEFT_BRACE',
    '}' => 'RIGHT_BRACE',
    ',' => 'COMMA',
    '.' => 'DOT',
    '-' => 'MINUS',
    '+' => 'PLUS',
    ';' => 'SEMICOLON',
    '/' => 'SLASH',
    '*' => 'STAR',
    '!' => 'BANG',
    '!=' => 'BANG_EQUAL',
    '=' => 'EQUAL',
    '==' => 'EQUAL_EQUAL',
    '>' => 'GREATER',
    '>=' => 'GREATER_EQUAL',
    '<' => 'LESS',
    '<=' => 'LESS_EQUAL'
  }.freeze

  # Constructor
  # @param source [String, NilClass] Optional. The text to tokenize
  def initialize(source = nil)
    @scanner = LoxxyRawScanner.new
    start_with(source)
  end

  # Set the text to tokenize.
  # @param source [String] The text to tokenize
  def start_with(source)
    @input = source
  end

  # Launch the scanning/tokenization of input text.
  # Returns an array of Rley token objects.
  # @return [Array<Rley::Lexical::Token>] array of token objects.
  def tokens
    raw_tokens = scanner.parse(input)
    cooked = raw_tokens.map do |(raw_type, raw_text, line, col)|
      pos = Rley::Lexical::Position.new(line, col + 1)
      convert(raw_type, raw_text, pos)
    end
    forelast = cooked.last
    last_col = forelast.position.column + forelast.lexeme.length
    last_pos = Rley::Lexical::Position.new(forelast.position.line, last_col)
    cooked << Rley::Lexical::Token.new(nil, 'EOF', last_pos)
    cooked
  end

  private

  # Convert the raw tokens from generated scanner into something edible by Rley.
  def convert(token_kind, token_text, pos)
    result = case token_kind
    when :SPECIAL
      Rley::Lexical::Token.new(token_text, Special2name[token_text])
    when :FALSE
      Rley::Lexical::Literal.new(false, token_text, 'FALSE')
    when :NUMBER
      num_val = token_text =~ /\.\d+$/ ? token_text.to_f : token_text.to_i
      Rley::Lexical::Literal.new(num_val, token_text, 'NUMBER')
    when :NIL
      Rley::Lexical::Literal.new(nil, token_text, 'NIL')
    when :STRING
      str_val = token_text[1..-2]
      pos.column = pos.column - 1 unless str_val.empty?
      Rley::Lexical::Literal.new(str_val, token_text, 'STRING')
    when :TRUE
      Rley::Lexical::Literal.new(true, token_text, 'TRUE')
    when :IDENTIFIER
      Rley::Lexical::Token.new(token_text, Keyword2name[token_text])
    else
      raise ScanError, "Error: [line #{pos.line}:#{column}]: Unexpected token #{token_text}"
    end

    result.position = pos
    result
  end
end # class
